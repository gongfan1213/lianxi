# 偏向锁、轻量级锁、重量级锁通俗易懂讲解（面试话术版）

---

## 1. 为什么有这些锁？
**面试话术：**
JVM为了提升synchronized的性能，引入了偏向锁、轻量级锁、重量级锁三种不同的锁状态。这样可以根据实际的线程竞争情况，动态选择最合适的加锁方式，既保证线程安全，又尽量减少性能损耗。

---

## 2. 偏向锁（Biased Locking）
### 2.1 概念
偏向锁适用于只有一个线程访问同步块的场景。

### 2.2 原理
- 当一个线程第一次获取锁时，JVM会在对象头Mark Word中记录该线程的ID。
- 之后只要这个线程再次进入同步块，不需要任何同步操作，直接进入。
- 如果有其他线程竞争，偏向锁会被撤销，升级为轻量级锁。

### 2.3 优点
- 没有CAS操作，几乎没有性能损耗。

### 2.4 适用场景
- 绝大多数情况下，锁只会被同一个线程反复获取，比如单线程环境或线程独占资源。

---

## 3. 轻量级锁（Lightweight Locking）
### 3.1 概念
轻量级锁适用于多个线程交替（但不是同时）访问同步块的场景。

### 3.2 原理
- 线程尝试用CAS操作将对象头中的Mark Word替换为指向自己栈帧的指针。
- 如果CAS成功，获得锁。
- 如果有其他线程竞争，CAS失败，进入自旋（不断尝试获取锁，不挂起线程）。
- 多个线程自旋失败后，锁会升级为重量级锁。

### 3.3 优点
- 避免线程阻塞和唤醒的开销。
- 适合短时间的锁竞争。

### 3.4 适用场景
- 多线程交替进入同步块，但竞争不激烈。

---

## 4. 重量级锁（Heavyweight Locking）
### 4.1 概念
重量级锁适用于多个线程同时竞争同一把锁的场景。

### 4.2 原理
- 线程获取不到锁时，会被挂起（阻塞），操作系统层面的互斥量（mutex）。
- 只有获得锁的线程才能进入同步块。
- 线程被唤醒和挂起涉及用户态和内核态切换，开销较大。

### 4.3 优点
- 保证线程安全。

### 4.4 缺点
- 性能开销大，阻塞和唤醒代价高。

### 4.5 适用场景
- 多线程高并发、竞争激烈的场景。

---

## 5. 三者的自动升级与降级
**面试话术：**
- 锁会根据实际竞争情况自动升级：无锁 → 偏向锁 → 轻量级锁 → 重量级锁。
- 一旦升级为重量级锁，不会自动降级。

---

## 6. 面试高频问题
1. 偏向锁、轻量级锁、重量级锁的区别？
   - 偏向锁适合单线程，轻量级锁适合少量线程交替，重量级锁适合高并发。
2. 为什么要有锁的升级机制？
   - 兼顾性能和线程安全，减少不必要的阻塞。
3. 偏向锁和轻量级锁的底层实现？
   - 偏向锁通过Mark Word记录线程ID，轻量级锁用CAS和自旋。
4. 什么时候会升级为重量级锁？
   - 多个线程同时竞争同一把锁，自旋失败时。

---

## 7. 总结表格
| 锁类型     | 适用场景         | 实现方式         | 优点           | 缺点           |
|------------|------------------|------------------|----------------|----------------|
| 偏向锁     | 单线程独占       | Mark Word线程ID  | 无同步开销     | 多线程失效     |
| 轻量级锁   | 线程交替竞争     | CAS+自旋         | 无阻塞/唤醒开销| 激烈竞争性能差 |
| 重量级锁   | 高并发激烈竞争   | 操作系统互斥量   | 线程安全       | 阻塞/唤醒慢   |

---

> 以上为偏向锁、轻量级锁、重量级锁的通俗易懂详细讲解，适合面试和日常复习。 