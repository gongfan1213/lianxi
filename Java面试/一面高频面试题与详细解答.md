# 一面高频面试题与详细解答

> 作者：小摆不算摆
> 来源：牛客网

---

## 1. 自我介绍
**面试话术：**
您好，我叫XXX，毕业于XXX大学XXX专业，主攻Java后端开发。实习期间参与过XXX项目，熟悉Java基础、JVM、并发编程、Spring生态、数据库和分布式相关技术。对代码质量和性能优化有较多实践，乐于团队协作和持续学习。

---

## 2. synchronized的底层原理？
**面试话术：**
synchronized是Java中最基础的同步手段。它的底层实现依赖于JVM的Monitor（监视器锁）机制。每个对象都有一个Monitor，synchronized加锁时会尝试获取对象的Monitor，只有获取到的线程才能进入同步块。JVM通过对象头中的Mark Word记录锁的状态，实现了无锁、偏向锁、轻量级锁、重量级锁的升级过程，以提升性能。

---

## 3. 字节码层面上相关的指令有了解吗？
**面试话术：**
在字节码层面，synchronized修饰方法会在方法的字节码中加上`ACC_SYNCHRONIZED`标志，修饰代码块则会插入`monitorenter`和`monitorexit`指令，分别在进入和退出同步块时加锁和释放锁。

---

## 4. synchronized锁升级和优化
**面试话术：**
JVM为了提升锁的性能，引入了锁的升级机制。对象初始为无锁状态，若只有一个线程访问，会升级为偏向锁，记录线程ID，避免CAS操作；有多线程竞争时升级为轻量级锁，采用CAS自旋；竞争激烈时升级为重量级锁，线程阻塞挂起。这样可以根据实际竞争情况动态调整锁的实现，减少性能损耗。

---

## 5. 偏向锁、轻量级锁、重量级锁在操作系统层面怎么实现的？
**面试话术：**
偏向锁主要是通过对象头Mark Word记录线程ID实现，避免CAS。轻量级锁通过CAS操作尝试将对象头指向当前线程的栈帧，失败则自旋。重量级锁则是操作系统层面的互斥量（mutex），线程会被挂起和唤醒，涉及用户态和内核态切换，开销较大。

---

## 6. 介绍一下volatile的实现原理，说一说JMM。
**面试话术：**
volatile保证变量的可见性和有序性。底层通过内存屏障（Memory Barrier）实现，写volatile变量时会将工作内存中的值刷新到主内存，读volatile变量时会从主内存读取最新值。JMM（Java内存模型）规定了多线程下变量的可见性、原子性和有序性，volatile正是JMM的一个重要实现。

---

## 7. volatile的另一个作用（防止指令重排序）
**面试话术：**
对，volatile除了保证可见性，还能防止指令重排序。JVM和CPU在执行时会对指令进行优化重排，volatile通过内存屏障禁止特定的重排序，保证代码执行的顺序性。

---

## 8. 从操作系统层面理解Java线程有哪些部分？组成元素？
**面试话术：**
Java线程本质上是操作系统线程的映射。主要包括线程ID、程序计数器、栈（Java虚拟机栈、本地方法栈）、堆中的线程对象、线程状态、优先级、上下文信息等。

---

## 9. 线程上下文切换时需要哪些东西保证线程能恢复？
**面试话术：**
线程上下文切换时，操作系统会保存当前线程的寄存器、程序计数器、栈指针等CPU上下文信息，切换到新线程时再恢复这些信息，保证线程能从上次中断的地方继续执行。

---

## 10. HashMap和ConcurrentHashMap（1.8之后），并发控制？
**面试话术：**
JDK1.8后，ConcurrentHashMap采用了分段锁+CAS+链表/红黑树结构。每个桶（Node）可以单独加锁，插入时用CAS保证并发安全，链表长度超过阈值会转为红黑树，提升查询效率。相比HashMap，ConcurrentHashMap支持高并发下的安全操作。

---

## 11. 单例模式
**面试话术：**
单例模式保证一个类只有一个实例。常见实现有饿汉式、懒汉式、双重检查锁（DCL）、静态内部类等。推荐用DCL结合volatile关键字，既保证线程安全又兼顾性能。

---

## 12. 工厂模式常用场景
**面试话术：**
工厂模式用于创建对象时不暴露具体实现，常用于解耦对象的创建和使用，比如Spring的Bean工厂、JDBC的Connection获取等。

---

## 13. 7层网络模型
**面试话术：**
OSI七层模型包括物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。每层负责不同的通信功能，便于网络协议的设计和实现。

---

## 14. 输入网址的全过程，TCP连接一定会断开吗？
**面试话术：**
输入网址后，浏览器先DNS解析获取IP，建立TCP连接（三次握手），发送HTTP请求，服务器响应，浏览器渲染页面。TCP连接不一定马上断开，HTTP1.1默认Keep-Alive复用连接，HTTP2.0支持多路复用。

---

## 15. http1.1和2.0主要区别
**面试话术：**
HTTP2.0支持多路复用、头部压缩、服务器推送等，极大提升了性能。HTTP1.1每次请求只能用一个连接，效率较低。

---

## 16. JVM运行时数据区域
**面试话术：**
JVM运行时数据区包括程序计数器、虚拟机栈、本地方法栈、堆、方法区。每个线程独享计数器和栈，堆和方法区线程共享。

---

## 17. 堆内存分配策略
**面试话术：**
堆分为新生代（Eden、S0、S1）和老年代。新对象优先分配在Eden区，大对象直接进老年代，长寿命对象经过多次GC后晋升到老年代。

---

## 18. 创建一个对象的步骤
**面试话术：**
类加载、在堆中分配内存、初始化对象头、执行实例初始化代码（构造方法）、返回对象引用。

---

## 19. 类加载机制
**面试话术：**
类加载分为加载、验证、准备、解析、初始化、使用、卸载七个阶段。采用双亲委派模型，优先由父类加载器加载，保证核心类安全。

---

## 20. 垃圾回收算法
**面试话术：**
常见算法有标记-清除、复制、标记-整理。新生代用复制算法，老年代用标记-清除和标记-整理。

---

## 21. 相关的垃圾回收器
**面试话术：**
常见有Serial、ParNew、Parallel Scavenge、CMS、G1等。G1是面向服务端的低延迟收集器。

---

## 22. 说一下索引结构？索引类型？
**面试话术：**
数据库常用B+树作为索引结构，支持范围查询和有序遍历。索引类型有主键索引、唯一索引、普通索引、联合索引、全文索引等。

---

## 23. 主键索引会需要回表查询吗？
**面试话术：**
主键索引一般不需要回表，数据直接存储在主键索引的叶子节点。非聚集索引（如普通索引）需要回表，通过索引找到主键再查数据。

---

## 24. 最左前缀原则？索引失效场景？
**面试话术：**
联合索引遵循最左前缀原则，必须从最左列开始匹配。索引失效常见于未用到最左列、使用了函数、like前置%、类型不一致等。

---

## 25. spring中bean加载流程？
**面试话术：**
Spring Bean加载包括实例化、属性注入、初始化、AOP代理等。核心流程有：读取Bean定义、实例化Bean、依赖注入、执行初始化方法、AOP代理、Bean就绪。

---

## 26. threadlocal的原理？怎么处理hash冲突的？
**面试话术：**
ThreadLocal为每个线程维护独立变量副本，底层用ThreadLocalMap存储。hash冲突时采用开放寻址法，线性探测下一个空槽。

---

## 27. redis常用的数据结构？
**面试话术：**
String、List、Set、Hash、ZSet（有序集合）等。每种结构适合不同场景，如排行榜用ZSet，计数用String，消息队列用List。

---

## 28. zset底层实现？插入流程？查找复杂度？
**面试话术：**
ZSet底层用跳表+哈希表。插入时先查找插入位置再插入节点，查找和插入平均O(logN)，最坏O(N)。

---

## 29. 缓存的主要内容？怎么解决缓存雪崩？
**面试话术：**
缓存常用于存储热点数据、配置信息等。防止缓存雪崩可采用：加随机过期时间、分批重建、限流降级、预热等手段。

---

## 30. 分布式锁锁的是什么？怎么实现？
**面试话术：**
分布式锁一般锁的是业务唯一标识（如订单号）。常用实现有基于Redis的setnx+过期时间、Zookeeper临时节点等。

---

## 手撕代码题

### 1. 线程安全的懒加载单例模式
```java
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

---

### 2. 128. 最长连续序列（mid）
**题目简述：**
给定一个未排序的整数数组，找出最长连续序列的长度。要求时间复杂度O(n)。

**代码实现：**
```java
public int longestConsecutive(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int num : nums) set.add(num);
    int maxLen = 0;
    for (int num : set) {
        if (!set.contains(num - 1)) {
            int cur = num, len = 1;
            while (set.contains(cur + 1)) {
                cur++;
                len++;
            }
            maxLen = Math.max(maxLen, len);
        }
    }
    return maxLen;
}
```

---

> 以上为一面高频Java面试题的详细问答整理，涵盖底层原理、代码实现、常见场景和注意点，便于系统复习和面试实战。 